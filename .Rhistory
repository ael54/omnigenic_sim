ls()
#Clear your workspace
rm(list = ls())
#Set the working directory
setwd("/Users/alipka/Library/CloudStorage/Box-Box/Sabbatical_Roslin_Institute/R_workspace/Sabbatical_Project")
home.dir <- getwd()
###Read in the R workspace of simulated data
load("2.FactorA..0.05.FactorB..0.05.FactorC..0.05.FactorD..3.Rep.Rdata")
#####Read in all of the packages that are necessary
#Read in prerequiste libaries for GAPIT
library('MASS')
library(multtest)
library(gplots)
library(rrBLUP)
#Read in GAPIT
setwd("Scripts_Necessary_for_GAPIT")
source("GAPIT_EMMA source code.txt")
source("GAPIT_Code_from_Internet_20120411_Allelic_Effect.r")
setwd(home.dir)
#Run a GWAS using a GLM for each subpopulation
list.of.subpopulation.traits <- list(directional.subpopulation.trait,
disruptive.subpopulation.trait,
stabilizing.subpopulation.trait)
#list.of.subpopulation.QTN <- list(directional.subpopulation.QTNs,
#                                  disruptive.subpopulation.QTNs,
#                                  stabilizing.subpopulation.QTNs)
list.of.subpopulation.SNPs <- list(directional.subpopulation.SNPs,
disruptive.subpopulation.SNPs,
stabilizing.subpopulation.SNPs)
names.of.subpopulations <- c("Directional.selection", "Disruptive.selection",
"Stabilizing.selection")
validation.set <- NULL
training.set.1 <- NULL
training.set.2 <- NULL
prediction.accuracy.GBLUP <- NULL
i <- 1
#Choose a particular subpopulation to be the validation population
this.validation.set <- i
this.training.set.1 <- which(1:length(names.of.subpopulations)!= i)[1]
this.training.set.2 <- which(1:length(names.of.subpopulations)!= i)[2]
##################################################################
#Run genomic prediction using one of the other two populations as
# the training set
this.training.set <- this.training.set.1
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 0)
my.Y.validation <- data.frame(row.names(list.of.subpopulation.traits[[this.validation.set]]),
list.of.subpopulation.traits[[this.validation.set]])
colnames(my.Y.validation) <- c("taxa", "Trait")
if(length(this.training.set)==1){
my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[this.training.set]]),
list.of.subpopulation.traits[[this.training.set]])
colnames(my.Y.training) <- c("taxa", "Trait")
}else{
counter <- 0
for(j in this.training.set){
this.my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[j]]),
list.of.subpopulation.traits[[j]])
colnames(this.my.Y.training) <- c("taxa", "Trait")
if(counter == 0){
my.Y.training <- this.my.Y.training
}else{
my.Y.training <- rbind(my.Y.training, this.my.Y.training)
}#end if(j == 1)
counter <- counter+1
}#end for(j in 1:length(this.training.set))
}#end else
my.Y.for.pipeline <- rbind(my.Y.validation, my.Y.training)
this.trait.name <- colnames(my.Y.for.pipeline)[2]
#Read in the genotypic data
my.G.validation <- data.frame(row.names(list.of.subpopulation.SNPs[[this.validation.set]]),
list.of.subpopulation.SNPs[[this.validation.set]])
colnames(my.G.validation)[1] <- "taxa"
if(length(this.training.set)==1){
my.G.training <- data.frame(row.names(list.of.subpopulation.SNPs[[this.training.set]]),
list.of.subpopulation.SNPs[[this.training.set]])
colnames(my.G.training)[1] <- "taxa"
}else{
counter <- 0
for(j in this.training.set){
this.my.G.training <- data.frame(row.names(list.of.subpopulation.SNPs[[j]]),
list.of.subpopulation.SNPs[[j]])
colnames(this.my.G.training)[1] <- "taxa"
if(counter == 0){
my.G.training <- this.my.G.training
}else{
my.G.training <- rbind(my.G.training, this.my.G.training)
}#end if(j == 1)
counter <- counter + 1
}#end for(j in 1:length(this.training.set))
}#end else
my.G.for.pipeline <- rbind(my.G.validation, my.G.training)
#########################
#Read in a list of all lines that are in the validation population
taxa.in.validation <- my.Y.validation[,1]
dir.create("Results.GBLUP.Test.20240327")
#Merge the genotypic data to the phenotypic data
#####################Turn this into a function
Y = my.Y.for.pipeline
Geno = my.G.for.pipeline
traitname = this.trait.name
path.for.results = "Results.GBLUP.Test.20240327/"
seed.number = 999
y <- as.matrix(Y[,-1])
G <- as.matrix(my.G.for.pipeline[,-1], nrow(y), ncol(my.G.for.pipeline[,-1]))
G <- G - 1
#Set up the object CV, which needs to go along for the ride in rrBLUP
CV=Y[,1:2]
CV[,2]=1
colnames(CV)=c("taxa","overall")
cv <- (as.matrix(CV[,-1]))
taxa.names <- CV[,1]
#Calculate the kinship matrix in rrBLUP
A1 <- A.mat(G,shrink=TRUE)
#Partition out the merged data so that the 282 is the training set, and the Ames panel is the validation set
pred <- which(taxa.names %in% taxa.in.validation)
#Let GAPIT do this - it can read in the data, match all genotype and phenotype data,
#   and calculate an additive genetic relatedness matrix
yNA <- y
yNA[pred] <- NA
#Train the GS model in the 282
data1 <- data.frame(y=yNA,gid=1:length(y), cv = cv)
the.cv.names <- NULL
for(j in 1:ncol(cv)) the.cv.names <- c(the.cv.names, paste("CV_",j,sep = ""))
colnames(data1) <- c("y","gid", the.cv.names)
rownames(A1) <- 1:nrow(A1)
ans1 <- kin.blup(data1,K=A1,geno="gid",pheno="y", covariate = the.cv.names)
#Evaluate prediction accuracy in the Ames panel
r.gy <-  cor(ans1$g[pred], y[pred])
r.gy
i
this.validation.set
this.training.set
#Merge the genotypic data to the phenotypic data
#####################Turn this into a function
Y = my.Y.for.pipeline
my.Y.validation <- data.frame(row.names(list.of.subpopulation.traits[[this.validation.set]]),
list.of.subpopulation.traits[[this.validation.set]])
colnames(my.Y.validation) <- c("taxa", "Trait")
if(length(this.training.set)==1){
my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[this.training.set]]),
list.of.subpopulation.traits[[this.training.set]])
colnames(my.Y.training) <- c("taxa", "Trait")
}else{
counter <- 0
for(j in this.training.set){
this.my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[j]]),
list.of.subpopulation.traits[[j]])
colnames(this.my.Y.training) <- c("taxa", "Trait")
if(counter == 0){
my.Y.training <- this.my.Y.training
}else{
my.Y.training <- rbind(my.Y.training, this.my.Y.training)
}#end if(j == 1)
counter <- counter+1
}#end for(j in 1:length(this.training.set))
}#end else
my.Y.for.pipeline <- rbind(my.Y.validation, my.Y.training)
this.trait.name <- colnames(my.Y.for.pipeline)[2]
#Read in the genotypic data
my.G.validation <- data.frame(row.names(list.of.subpopulation.SNPs[[this.validation.set]]),
list.of.subpopulation.SNPs[[this.validation.set]])
colnames(my.G.validation)[1] <- "taxa"
if(length(this.training.set)==1){
my.G.training <- data.frame(row.names(list.of.subpopulation.SNPs[[this.training.set]]),
list.of.subpopulation.SNPs[[this.training.set]])
colnames(my.G.training)[1] <- "taxa"
}else{
counter <- 0
for(j in this.training.set){
this.my.G.training <- data.frame(row.names(list.of.subpopulation.SNPs[[j]]),
list.of.subpopulation.SNPs[[j]])
colnames(this.my.G.training)[1] <- "taxa"
if(counter == 0){
my.G.training <- this.my.G.training
}else{
my.G.training <- rbind(my.G.training, this.my.G.training)
}#end if(j == 1)
counter <- counter + 1
}#end for(j in 1:length(this.training.set))
}#end else
my.G.for.pipeline <- rbind(my.G.validation, my.G.training)
my.G.for.pipeline.core <- my.G.for.pipeline[,which(colnames(my.G.for.pipeline) %in%
paste("X", this.simulated.trait$core.genes$core.genes, sep = ""))]
my.G.for.pipeline.peripheral <- my.G.for.pipeline[,-c(1,which(colnames(my.G.for.pipeline) %in%
paste("X", this.simulated.trait$core.genes$core.genes, sep = "")))]
#########################
#Read in a list of all lines that are in the validation population
taxa.in.validation <- my.Y.validation[,1]
dir.create("Results.multi.kernel.add.Test.20240327")
#Merge the genotypic data to the phenotypic data
#####################Turn this into a function
Y = my.Y.for.pipeline
traitname = this.trait.name
path.for.results = "Results.multi.kernel.add.Test.20240327/"
seed.number = 999
y <- as.matrix(Y[,-1])
this.simulated.trait$core.genes
i <- 1
# Extract the chromosome and bp position of the start site
row.number.of.QTN <- which(the.physical.map.of.QTLs$id == this.simulated.trait$core.genes$core.genes[j])
this.chr.start <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.start <- the.physical.map.of.QTLs$pos[row.number.of.QTN] - 0.05
# Extract the chromosome and bp position of the stop site
this.chr.stop <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.stop <- the.physical.map.of.QTLs$pos[row.number.of.QTN] + 0.05
View(the.physical.map.of.SNPs)
View(my.G.for.pipeline)
dim(my.G.for.pipeline)
dim(the.physical.map.of.SNPs)
is.numeric(the.physical.map.of.SNPs$chr)
str(the.physical.map.of.SNPs)
as.numeric(the.physical.map.of.SNPs$chr)
as.numeric(the.physical.map.of.SNPs$pos)
j
row.number.of.QTN <- which(the.physical.map.of.QTLs$id == this.simulated.trait$core.genes$core.genes[j])
this.chr.start <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.start <- the.physical.map.of.QTLs$pos[row.number.of.QTN] - 0.05
# Extract the chromosome and bp position of the stop site
this.chr.stop <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.stop <- the.physical.map.of.QTLs$pos[row.number.of.QTN] + 0.05
this.chr.stop
this.bp.stop
this.simulated.trait$core.genes$core.genes[j]
row.number.of.QTN <- which(the.physical.map.of.QTLs$id == this.simulated.trait$core.genes$core.genes[j])
this.chr.start <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.start <- the.physical.map.of.QTLs$pos[row.number.of.QTN] - 0.05
# Extract the chromosome and bp position of the stop site
this.chr.stop <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.stop <- the.physical.map.of.QTLs$pos[row.number.of.QTN] + 0.05
#Identify the row numbers of the desired SNPs
#In most cases the genomic region of interest will be on the same chromosome
# Therefore the following code will be used
if(this.chr.start == this.chr.stop){
these.col.numbers <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start)
& (as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop)
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
}else{
these.col.numbers.part.1 <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start))
these.col.numbers.part.2 <- which((as.numeric(as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop))
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
these.row.numbers <- c(these.row.numbers.part.1, these.row.numbers.part.2)
}#end if(this.chr.start == this.chr.stop)
these.row.numbers
# Therefore the following code will be used
if(this.chr.start == this.chr.stop){
these.col.numbers <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start)
& (as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop)
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
}else{
these.col.numbers.part.1 <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start))
these.col.numbers.part.2 <- which((as.numeric(as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop))
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
these.col.numbers <- c(these.row.numbers.part.1, these.row.numbers.part.2)
}#end if(this.chr.start == this.chr.stop)
these.col.numbers
my.G.for.pipeline[c(201:214),]
my.G.for.pipeline[201:214,]
the.physical.map.of.SNPs$id[201:214]
colnames(my.G.for.pipeline)[these.col.numbers]
the.physical.map.of.SNPs$id[these.col.numbers]
#Add 1 to all column numbers because the first column of myG is the taxa namess
these.col.numbers + 1
these.col.numbers
#Obtain the row numbers of SNPs that are within 0.05 cM of each QTN
list.of.col.numbers <- NULL
for(j in 1:nrow(this.simulated.trait$core.genes)){
# Extract the chromosome and bp position of the start site
row.number.of.QTN <- which(the.physical.map.of.QTLs$id == this.simulated.trait$core.genes$core.genes[j])
this.chr.start <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.start <- the.physical.map.of.QTLs$pos[row.number.of.QTN] - 0.05
# Extract the chromosome and bp position of the stop site
this.chr.stop <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.stop <- the.physical.map.of.QTLs$pos[row.number.of.QTN] + 0.05
#Identify the row numbers of the desired SNPs
#In most cases the genomic region of interest will be on the same chromosome
# Therefore the following code will be used
if(this.chr.start == this.chr.stop){
these.col.numbers <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start)
& (as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop)
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
}else{
these.col.numbers.part.1 <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start))
these.col.numbers.part.2 <- which((as.numeric(as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop))
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
these.col.numbers <- c(these.row.numbers.part.1, these.row.numbers.part.2)
}#end if(this.chr.start == this.chr.stop)
#Add 1 to all column numbers because the first column of myG is the taxa namess
these.col.numbers <- these.col.numbers + 1
# Append them to a list of positions (i.e. row numbers)
list.of.col.numbers <- c(list.of.col.numbers, these.col.numbers)
}#End for(j in 1:nrow(the.physical.map.of.QTLs))
list.of.col.numbers
n
my.G.for.pipeline.core <- my.G.for.pipeline[,which(list.of.col.numbers)]
my.G.for.pipeline.core <- my.G.for.pipeline[,list.of.col.numbers]
View(my.G.for.pipeline.core)
dim(my.G.for.pipeline.core)
my.G.for.pipeline.peripheral <- my.G.for.pipeline[,-c(1,list.of.col.numbers)]
dim(my.G.for.pipeline.peripheral)
123+877
#Obtain the row numbers of SNPs that are within 0.05 cM of each QTN
list.of.col.numbers <- NULL
for(j in 1:nrow(this.simulated.trait$core.genes)){
# Extract the chromosome and bp position of the start site
row.number.of.QTN <- which(the.physical.map.of.QTLs$id == this.simulated.trait$core.genes$core.genes[j])
this.chr.start <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.start <- the.physical.map.of.QTLs$pos[row.number.of.QTN] - 0.05
# Extract the chromosome and bp position of the stop site
this.chr.stop <- as.numeric(the.physical.map.of.QTLs$chr[row.number.of.QTN])
this.bp.stop <- the.physical.map.of.QTLs$pos[row.number.of.QTN] + 0.05
#Identify the row numbers of the desired SNPs
#In most cases the genomic region of interest will be on the same chromosome
# Therefore the following code will be used
if(this.chr.start == this.chr.stop){
these.col.numbers <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start)
& (as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop)
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
}else{
these.col.numbers.part.1 <- which((as.numeric(the.physical.map.of.SNPs$chr)==this.chr.start)
& (as.numeric(the.physical.map.of.SNPs$pos) >= this.bp.start))
these.col.numbers.part.2 <- which((as.numeric(as.numeric(the.physical.map.of.SNPs$chr)==this.chr.stop))
& (as.numeric(the.physical.map.of.SNPs$pos) <= this.bp.stop))
these.col.numbers <- c(these.row.numbers.part.1, these.row.numbers.part.2)
}#end if(this.chr.start == this.chr.stop)
#Add 1 to all column numbers because the first column of myG is the taxa namess
these.col.numbers <- these.col.numbers + 1
# Append them to a list of positions (i.e. row numbers)
list.of.col.numbers <- c(list.of.col.numbers, these.col.numbers)
}#End for(j in 1:nrow(the.physical.map.of.QTLs))
my.G.for.pipeline.core <- my.G.for.pipeline[,list.of.col.numbers]
my.G.for.pipeline.peripheral <- my.G.for.pipeline[,-c(1,list.of.col.numbers)]
#Obtain the prediction accuracies using GBLUP
validation.set <- NULL
training.set.1 <- NULL
training.set.2 <- NULL
prediction.accuracy.GBLUP <- NULL
for(i in 1:length(names.of.subpopulations)){
#Choose a particular subpopulation to be the validation population
this.validation.set <- i
this.training.set.1 <- which(1:length(names.of.subpopulations)!= i)[1]
this.training.set.2 <- which(1:length(names.of.subpopulations)!= i)[2]
##################################################################
#Run genomic prediction using one of the other two populations as
# the training set
this.training.set <- this.training.set.1
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 0)
####Standard GBLUP model
source("QG_Analysis_Code/Run_GBLUP_Train_in_One_Pop_Validate_in_Another_using_SNPs.R")
prediction.accuracy.GBLUP <- c(prediction.accuracy.GBLUP, r.gy)
##################################################################
#Run genomic prediction using the second of the other two populations as
# the training set
this.training.set <- this.training.set.2
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 0)
training.set.2 <- c(training.set.2, 1)
#Standard GBLUP model
source("QG_Analysis_Code/Run_GBLUP_Train_in_One_Pop_Validate_in_Another_using_SNPs.R")
prediction.accuracy.GBLUP <- c(prediction.accuracy.GBLUP, r.gy)
#Multi-kernel model where the additive effects of core and peripheral
# QTN are separate
#Multi-kernel model where the additive and epistatic effects of core and peripheral
# QTN are separate
##################################################################
#Run genomic prediction using the second of both of the other two
# populations as the training set
this.training.set <- c(this.training.set.1, this.training.set.2)
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 1)
#Standard GBLUP model
source("QG_Analysis_Code/Run_GBLUP_Train_in_One_Pop_Validate_in_Another_using_SNPs.R")
prediction.accuracy.GBLUP <- c(prediction.accuracy.GBLUP, r.gy)
#Multi-kernel model where the additive effects of core and peripheral
# QTN are separate
#Multi-kernel model where the additive and epistatic effects of core and peripheral
# QTN are separate
} # End for(i in 1:length(names.of.subpopulations))
#To-do: compile the results into a data frame
prediction.accuracies.SNPs <- data.frame(validation.set, training.set.1, training.set.2 ,
prediction.accuracy.GBLUP)
View(prediction.accuracies.SNPs)
library(sommer)
#Obtain the prediction accuracies for the multi-kernel-models
validation.set <- NULL
training.set.1 <- NULL
training.set.2 <- NULL
prediction.accuracy.Multi.Kern.No.Epi <- NULL
prediction.accuracy.Multi.Kern.With.Epi <- NULL
for(i in 1:length(names.of.subpopulations)){
#Choose a particular subpopulation to be the validation population
this.validation.set <- i
this.training.set.1 <- which(1:length(names.of.subpopulations)!= i)[1]
this.training.set.2 <- which(1:length(names.of.subpopulations)!= i)[2]
##################################################################
#Run genomic prediction using one of the other two populations as
# the training set
this.training.set <- this.training.set.1
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 0)
#####Multi-kernel model where the additive effects of core and peripheral
# QTN are separate
source("QG_Analysis_Code/Run_Multi_Kernel_BLUP_Add_Only_using_SNPs.R")
prediction.accuracy.Multi.Kern.No.Epi <- c(prediction.accuracy.Multi.Kern.No.Epi,  r.gy.add.mult.kern)
#####Multi-kernel model where the additive and epistatic effects of core and peripheral
# QTN are separate
source("QG_Analysis_Code/Run_Multi_Kernel_BLUP_Add_and_Epi_using_SNPs.R")
prediction.accuracy.Multi.Kern.With.Epi <- c(prediction.accuracy.Multi.Kern.With.Epi, r.gy.add.epi.mult.kern)
##################################################################
#Run genomic prediction using the second of the other two populations as
# the training set
this.training.set <- this.training.set.2
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 0)
training.set.2 <- c(training.set.2, 1)
#####Multi-kernel model where the additive effects of core and peripheral
# QTN are separate
source("QG_Analysis_Code/Run_Multi_Kernel_BLUP_Add_Only_using_SNPs.R")
prediction.accuracy.Multi.Kern.No.Epi <- c(prediction.accuracy.Multi.Kern.No.Epi,  r.gy.add.mult.kern)
#####Multi-kernel model where the additive and epistatic effects of core and peripheral
# QTN are separate
source("QG_Analysis_Code/Run_Multi_Kernel_BLUP_Add_and_Epi_using_SNPs.R")
prediction.accuracy.Multi.Kern.With.Epi <- c(prediction.accuracy.Multi.Kern.With.Epi, r.gy.add.epi.mult.kern)
##################################################################
#Run genomic prediction using the second of both of the other two
# populations as the training set
this.training.set <- c(this.training.set.1, this.training.set.2)
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 1)
#####Multi-kernel model where the additive effects of core and peripheral
# QTN are separate
source("QG_Analysis_Code/Run_Multi_Kernel_BLUP_Add_Only_using_SNPs.R")
prediction.accuracy.Multi.Kern.No.Epi <- c(prediction.accuracy.Multi.Kern.No.Epi,  r.gy.add.mult.kern)
#####Multi-kernel model where the additive and epistatic effects of core and peripheral
# QTN are separate
source("QG_Analysis_Code/Run_Multi_Kernel_BLUP_Add_and_Epi_using_SNPs.R")
prediction.accuracy.Multi.Kern.With.Epi <- c(prediction.accuracy.Multi.Kern.With.Epi, r.gy.add.epi.mult.kern)
} # End for(i in 1:length(names.of.subpopulations))
prediction.accuracies.SNPs <- data.frame(prediction.accuracies.SNPs, prediction.accuracy.Multi.Kern.No.Epi,
prediction.accuracy.Multi.Kern.With.Epi)
View(prediction.accuracies.SNPs)
lme4()
