k <- 0.05
el <- 0.05
rep <- 1
factor.A <- i
factor.B <- j
factor.C <- k
factor.D <- el
this.rep <- rep
this.rep <- 3
load(paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep.Rdata", sep = ""))
factor.A <- 2
load(paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep.Rdata", sep = ""))
#Keep track of what setting you are on
this.setting <- c(this.setting, paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep", sep = ""))
#Record which setting you are on
this.setting <- NULL
#Keep track of what setting you are on
this.setting <- c(this.setting, paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep", sep = ""))
#Run a GWAS using a GLM for each subpopulation
list.of.subpopulation.traits <- list(directional.subpopulation.trait,
disruptive.subpopulation.trait,
stabilizing.subpopulation.trait)
list.of.subpopulation.QTN <- list(directional.subpopulation.QTNs,
disruptive.subpopulation.QTNs,
stabilizing.subpopulation.QTNs)
#list.of.subpopulation.SNPs <- list(directional.subpopulation.SNPs,
#                                   disruptive.subpopulation.SNPs,
#                                   stabilizing.subpopulation.SNPs)
names.of.subpopulations <- c("Directional.selection", "Disruptive.selection",
"Stabilizing.selection")
library(sommer)
#Read in prerequiste libaries for GAPIT
library('MASS')
library(multtest)
library(gplots)
library(sommer)
#Read in GAPIT
setwd("Scripts_Necessary_for_GAPIT")
source("GAPIT_EMMA source code.txt")
source("GAPIT_Code_from_Internet_20120411_Allelic_Effect.r")
setwd(home.dir)
#Obtain the prediction accuracies using GBLUP
validation.set <- NULL
training.set.1 <- NULL
training.set.2 <- NULL
prediction.accuracy.GBLUP <- NULL
i
eye <- 1
names.of.subpopulations
validation.set <- NULL
training.set.1 <- NULL
training.set.2 <- NULL
prediction.accuracy.GBLUP <- NULL
this.validation.set <- eye
this.training.set.1 <- which(1:length(names.of.subpopulations)!= eye)[1]
this.training.set.2 <- which(1:length(names.of.subpopulations)!= eye)[2]
# the training set
this.training.set <- this.training.set.1
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 0)
my.Y.validation <- data.frame(row.names(list.of.subpopulation.traits[[this.validation.set]]),
list.of.subpopulation.traits[[this.validation.set]])
colnames(my.Y.validation) <- c("taxa", "Trait")
if(length(this.training.set)==1){
my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[this.training.set]]),
list.of.subpopulation.traits[[this.training.set]])
colnames(my.Y.training) <- c("taxa", "Trait")
}else{
counter <- 0
for(j in this.training.set){
this.my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[j]]),
list.of.subpopulation.traits[[j]])
colnames(this.my.Y.training) <- c("taxa", "Trait")
if(counter == 0){
my.Y.training <- this.my.Y.training
}else{
my.Y.training <- rbind(my.Y.training, this.my.Y.training)
}#end if(j == 1)
counter <- counter+1
}#end for(j in 1:length(this.training.set))
}#end else
my.Y.for.pipeline <- rbind(my.Y.validation, my.Y.training)
this.trait.name <- colnames(my.Y.for.pipeline)[2]
#Read in the genotypic data
my.G.validation <- data.frame(row.names(list.of.subpopulation.QTN[[this.validation.set]]),
list.of.subpopulation.QTN[[this.validation.set]])
colnames(my.G.validation)[1] <- "taxa"
if(length(this.training.set)==1){
my.G.training <- data.frame(row.names(list.of.subpopulation.QTN[[this.training.set]]),
list.of.subpopulation.QTN[[this.training.set]])
colnames(my.G.training)[1] <- "taxa"
}else{
counter <- 0
for(j in this.training.set){
this.my.G.training <- data.frame(row.names(list.of.subpopulation.QTN[[j]]),
list.of.subpopulation.QTN[[j]])
colnames(this.my.G.training)[1] <- "taxa"
if(counter == 0){
my.G.training <- this.my.G.training
}else{
my.G.training <- rbind(my.G.training, this.my.G.training)
}#end if(j == 1)
counter <- counter + 1
}#end for(j in 1:length(this.training.set))
}#end else
my.G.for.pipeline <- rbind(my.G.validation, my.G.training)
#########################
#Read in a list of all lines that are in the validation population
taxa.in.validation <- my.Y.validation[,1]
dir.create("Results.GBLUP.Test.20240325")
#Merge the genotypic data to the phenotypic data
#####################Turn this into a function
Y = my.Y.for.pipeline
Geno = my.G.for.pipeline
traitname = this.trait.name
path.for.results = "Results.GBLUP.Test.20240325/"
seed.number = 999
y <- as.matrix(Y[,-1])
G <- as.matrix(my.G.for.pipeline[,-1], nrow(y), ncol(my.G.for.pipeline[,-1]))
G <- G - 1
#Calculate the kinship matrix in rrBLUP
A1 <- A.mat(G)
colnames(A1) <- rownames(A1) <- c(1:nrow(y))
sample.size <- nrow(y)
#Partition out the merged data so that the 282 is the training set, and the Ames panel is the validation set
pred <- which(taxa.names %in% taxa.in.validation)
#Let GAPIT do this - it can read in the data, match all genotype and phenotype data,
#   and calculate an additive genetic relatedness matrix
yNA <- y
taxa.names
taxa.in.validation
#########################
#Read in a list of all lines that are in the validation population
taxa.in.validation <- my.Y.validation[,1]
#Partition out the merged data so that the 282 is the training set, and the Ames panel is the validation set
pred <- which(taxa.names %in% taxa.in.validation)
my.Y.validation <- data.frame(row.names(list.of.subpopulation.traits[[this.validation.set]]),
list.of.subpopulation.traits[[this.validation.set]])
colnames(my.Y.validation) <- c("taxa", "Trait")
if(length(this.training.set)==1){
my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[this.training.set]]),
list.of.subpopulation.traits[[this.training.set]])
colnames(my.Y.training) <- c("taxa", "Trait")
}else{
counter <- 0
for(j in this.training.set){
this.my.Y.training <- data.frame(row.names(list.of.subpopulation.traits[[j]]),
list.of.subpopulation.traits[[j]])
colnames(this.my.Y.training) <- c("taxa", "Trait")
if(counter == 0){
my.Y.training <- this.my.Y.training
}else{
my.Y.training <- rbind(my.Y.training, this.my.Y.training)
}#end if(j == 1)
counter <- counter+1
}#end for(j in 1:length(this.training.set))
}#end else
my.Y.for.pipeline <- rbind(my.Y.validation, my.Y.training)
this.trait.name <- colnames(my.Y.for.pipeline)[2]
#Read in the genotypic data
my.G.validation <- data.frame(row.names(list.of.subpopulation.QTN[[this.validation.set]]),
list.of.subpopulation.QTN[[this.validation.set]])
colnames(my.G.validation)[1] <- "taxa"
if(length(this.training.set)==1){
my.G.training <- data.frame(row.names(list.of.subpopulation.QTN[[this.training.set]]),
list.of.subpopulation.QTN[[this.training.set]])
colnames(my.G.training)[1] <- "taxa"
}else{
counter <- 0
for(j in this.training.set){
this.my.G.training <- data.frame(row.names(list.of.subpopulation.QTN[[j]]),
list.of.subpopulation.QTN[[j]])
colnames(this.my.G.training)[1] <- "taxa"
if(counter == 0){
my.G.training <- this.my.G.training
}else{
my.G.training <- rbind(my.G.training, this.my.G.training)
}#end if(j == 1)
counter <- counter + 1
}#end for(j in 1:length(this.training.set))
}#end else
my.G.for.pipeline <- rbind(my.G.validation, my.G.training)
#########################
#Read in a list of all lines that are in the validation population
taxa.in.validation <- my.Y.validation[,1]
dir.create("Results.GBLUP.Test.20240325")
#Merge the genotypic data to the phenotypic data
#####################Turn this into a function
Y = my.Y.for.pipeline
Geno = my.G.for.pipeline
traitname = this.trait.name
path.for.results = "Results.GBLUP.Test.20240325/"
seed.number = 999
y <- as.matrix(Y[,-1])
G <- as.matrix(my.G.for.pipeline[,-1], nrow(y), ncol(my.G.for.pipeline[,-1]))
G <- G - 1
#Set up the object CV, which needs to go along for the ride in rrBLUP
CV=Y[,1:2]
CV[,2]=1
colnames(CV)=c("taxa","overall")
cv <- (as.matrix(CV[,-1]))
taxa.names <- CV[,1]
#Calculate the kinship matrix in rrBLUP
A1 <- A.mat(G)
colnames(A1) <- rownames(A1) <- c(1:nrow(y))
sample.size <- nrow(y)
#Partition out the merged data so that the 282 is the training set, and the Ames panel is the validation set
pred <- which(taxa.names %in% taxa.in.validation)
#Let GAPIT do this - it can read in the data, match all genotype and phenotype data,
#   and calculate an additive genetic relatedness matrix
yNA <- y
yNA[pred] <- NA
#Train the GS model in the 282
data1 <- data.frame(y=yNA,gid=1:length(y), cv = cv)
the.cv.names <- NULL
for(j in 1:ncol(cv)) the.cv.names <- c(the.cv.names, paste("CV_",j,sep = ""))
colnames(data1) <- c("y","gid", the.cv.names)
data1$gid <- as.character(data1$gid)
ans1 <- mmer(y~1, random = ~vsr(gid, Gu = A1.core),
data = data2, verbose = FALSE)
ans1 <- mmer(y~1, random = ~vsr(gid, Gu = A1.core),
data = data1, verbose = FALSE)
ans1 <- mmer(y~1, random = ~vsr(gid, Gu = A1),
data = data1, verbose = FALSE)
GEBVs <- as.data.frame(ans.multiple.kernel$U$`u:gid`$y)
GEBVs <- as.data.frame(ans1$U$`u:gid`$y)
GEBVs  <- data.frame(as.numeric(rownames(GEBVs)), GEBVs )
GEBVs <- GEBVs[order(GEBVs[,1]),]
#Evaluate prediction accuracy in the Ames panel
r.gy <-  cor(GEBVs[pred,2], y[pred])
r.gy
####Standard GBLUP model
source("QG_Analysis_Code/Run_GBLUP_Train_in_One_Pop_Validate_in_Another.R")
prediction.accuracy.GBLUP <- c(prediction.accuracy.GBLUP, r.gy)
prediction.accuracy.GBLUP
#Obtain the prediction accuracies for the multi-kernel-models
validation.set <- NULL
training.set.1 <- NULL
training.set.2 <- NULL
prediction.accuracy.Multi.Kern.No.Epi <- NULL
prediction.accuracy.Multi.Kern.With.Epi <- NULL
this.validation.set <- eye
this.training.set.1 <- which(1:length(names.of.subpopulations)!= eye)[1]
this.training.set.2 <- which(1:length(names.of.subpopulations)!= eye)[2]
this.training.set <- this.training.set.1
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 0)
#####Multi-kernel model where the additive effects of core and peripheral
# QTN are separate
source("QG_Analysis_Code/Run_Multi_Kernel_BLUP_Add_Only.R")
prediction.accuracy.Multi.Kern.No.Epi <- c(prediction.accuracy.Multi.Kern.No.Epi,  r.gy.add.mult.kern)
prediction.accuracy.Multi.Kern.No.Epi
prediction.accuracy.GBLUP
eye <- 1
#Choose a particular subpopulation to be the validation population
this.validation.set <- eye
this.training.set.1 <- which(1:length(names.of.subpopulations)!= eye)[1]
this.training.set.2 <- which(1:length(names.of.subpopulations)!= eye)[2]
##################################################################
#Run genomic prediction using one of the other two populations as
# the training set
this.training.set <- this.training.set.1
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 0)
####Standard GBLUP model
source("QG_Analysis_Code/Run_GBLUP_Train_in_One_Pop_Validate_in_Another_using_SNPs.R")
#Run a GWAS using a GLM for each subpopulation
list.of.subpopulation.traits <- list(directional.subpopulation.trait,
disruptive.subpopulation.trait,
stabilizing.subpopulation.trait)
#list.of.subpopulation.QTN <- list(directional.subpopulation.QTNs,
#                                  disruptive.subpopulation.QTNs,
#                                  stabilizing.subpopulation.QTNs)
list.of.subpopulation.SNPs <- list(directional.subpopulation.SNPs,
disruptive.subpopulation.SNPs,
stabilizing.subpopulation.SNPs)
names.of.subpopulations <- c("Directional.selection", "Disruptive.selection",
"Stabilizing.selection")
#Obtain the prediction accuracies using GBLUP
validation.set <- NULL
training.set.1 <- NULL
training.set.2 <- NULL
prediction.accuracy.SNP.GBLUP <- NULL
#Choose a particular subpopulation to be the validation population
this.validation.set <- eye
this.training.set.1 <- which(1:length(names.of.subpopulations)!= eye)[1]
this.training.set.2 <- which(1:length(names.of.subpopulations)!= eye)[2]
##################################################################
#Run genomic prediction using one of the other two populations as
# the training set
this.training.set <- this.training.set.1
validation.set <-c(validation.set, this.validation.set)
training.set.1 <- c(training.set.1, 1)
training.set.2 <- c(training.set.2, 0)
####Standard GBLUP model
source("QG_Analysis_Code/Run_GBLUP_Train_in_One_Pop_Validate_in_Another_using_SNPs.R")
prediction.accuracy.SNP.GBLUP <- c(prediction.accuracy.SNP.GBLUP, r.gy)
prediction.accuracy.SNP.GBLUP
#Calculate the spearman correlation coefficients between additive
# effect estimates core and peripheral QTNs
source("QG_Analysis_Code/Run_GWAS_on_QTNs.R")
#Object for spearman correlation coefficients between core and peripheral QTNs
spearman.correlations.between.core.QTNs
spearman.correlations.between.peripheral.QTNs
#Initialize objects that will store GWAS results
these.spearman.rank.correlation.between.GWAS.core.QTNS <- list()
these.spearman.rank.correlation.between.GWAS.peripheral.QTNS <- list()
#Keep track of what setting you are on
this.setting <-  paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep", sep = "")
#Initialize objects that will store GWAS results
these.spearman.rank.correlation.between.GWAS.core.QTNs <- list()
these.spearman.rank.correlation.between.GWAS.peripheral.QTNs <- list()
#This count variable will help with appending to these lists storing
# GWAS and GS summary statistics
count <- 1
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
these.spearman.rank.correlation.between.GWAS.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs)
names(these.spearman.rank.correlation.between.GWAS.core.QTNs) <-
c(names(these.spearman.rank.correlation.between.GWAS.core.QTNs),
this.setting)
these.spearman.rank.correlation.between.GWAS.core.QTNs$2.FactorA..0.05.FactorB..0.05.FactorC..0.05.FactorD..3.Rep
these.spearman.rank.correlation.between.GWAS.core.QTNs
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs) <-
c(names(these.spearman.rank.correlation.between.GWAS.core.QTNs),
this.setting)
these.spearman.rank.correlation.between.GWAS.core.QTNs <- list()
these.spearman.rank.correlation.between.GWAS.peripheral.QTNs <- list()
##############################################################
#### Append GWAS Results
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs) <-
c(names(these.spearman.rank.correlation.between.GWAS.core.QTNs),
this.setting)
this.setting <- "Hey.there"
##############################################################
#### Append GWAS Results
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
these.spearman.rank.correlation.between.GWAS.core.QTNs
count <- 2
##############################################################
#### Append GWAS Results
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
these.spearman.rank.correlation.between.GWAS.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs) <-
c(names(these.spearman.rank.correlation.between.GWAS.core.QTNs),
this.setting)
names(these.spearman.rank.correlation.between.GWAS.core.QTNs)
this.setting
names(these.spearman.rank.correlation.between.GWAS.core.QTNs) <-
c(names(these.spearman.rank.correlation.between.GWAS.core.QTNs),
this.setting)
#Initialize objects that will store GWAS results
these.spearman.rank.correlation.between.GWAS.core.QTNs <- list()
#Keep track of what setting you are on
this.setting <-  paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep", sep = "")
##############################################################
#### Append GWAS Results
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
these.spearman.rank.correlation.between.GWAS.core.QTNs
count <- 1
#Initialize objects that will store GWAS results
these.spearman.rank.correlation.between.GWAS.core.QTNs <- list()
##############################################################
#### Append GWAS Results
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
these.spearman.rank.correlation.between.GWAS.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs)
names(these.spearman.rank.correlation.between.GWAS.core.QTNs) <-
c(names(these.spearman.rank.correlation.between.GWAS.core.QTNs),
this.setting)
these.spearman.rank.correlation.between.GWAS.core.QTNs
#Update count for the next iteration of this loop
count <- count + 1
this.setting <- "Wheeeee"
count
##############################################################
#### Append GWAS Results
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs)
names(these.spearman.rank.correlation.between.GWAS.core.QTNs) <-
c(names(these.spearman.rank.correlation.between.GWAS.core.QTNs),
this.setting)
names(these.spearman.rank.correlation.between.GWAS.core.QTNs)[count] <-
this.setting
count <- 1
#Initialize objects that will store GWAS results
these.spearman.rank.correlation.between.GWAS.core.QTNs <- list()
these.spearman.rank.correlation.between.GWAS.peripheral.QTNs <- list()
#Keep track of what setting you are on
this.setting <-  paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep", sep = "")
##############################################################
#### Append GWAS Results
#Append results to the lists you created before the start of this rep
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs)[count] <-
this.setting
count <- 2
this.setting <- "I.like.haggis"
these.spearman.rank.correlation.between.GWAS.core.QTNs[[count]] <-
spearman.correlations.between.core.QTNs
names(these.spearman.rank.correlation.between.GWAS.core.QTNs)[count] <-
this.setting
these.spearman.rank.correlation.between.GWAS.core.QTNs
these.spearman.rank.correlation.between.GWAS.peripheral.QTNs[[count]] <-
spearman.correlations.between.peripheral.QTNs
names(these.spearman.rank.correlation.between.GWAS.peripheral.QTNs)[count] <-
this.setting
these.spearman.rank.correlation.between.GWAS.peripheral.QTNs
these.spearman.rank.correlation.between.GWAS.core.SNPs <- list()
these.spearman.rank.correlation.between.GWAS.peripheral.SNPs <- list()
#Calculate the spearman correlation coefficients between additive
# effect estimates of "Core SNPs" that are within 0.05 cM of core QTNs
# and "Peripheral SNPs that are not"
source("QG_Analysis_Code/Run_GWAS_on_SNPs.R")
#Object for spearman correlation coefficients between core and peripheral QTNs
spearman.correlations.between.core.SNPs
spearman.correlations.between.peripheral.SNPs
these.spearman.rank.correlation.between.GWAS.core.SNPs[[count]] <-
spearman.correlations.between.core.SNPs
names(these.spearman.rank.correlation.between.GWAS.core.SNPs)[count] <-
this.setting
these.spearman.rank.correlation.between.GWAS.peripheral.SNPs[[count]] <-
spearman.correlations.between.peripheral.SNPs
names(these.spearman.rank.correlation.between.GWAS.peripheral.SNPs)[count] <-
this.setting
these.spearman.rank.correlation.between.GWAS.core.SNPs
count
count <- 1
#Keep track of what setting you are on
this.setting <-  paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep", sep = "")
these.spearman.rank.correlation.between.GWAS.core.SNPs <- list()
these.spearman.rank.correlation.between.GWAS.peripheral.SNPs <- list()
#Keep track of what setting you are on
this.setting <-  paste(factor.A,".FactorA..",factor.B, ".FactorB..",
factor.C,".FactorC..",factor.D,".FactorD..",
this.rep, ".Rep", sep = "")
these.spearman.rank.correlation.between.GWAS.core.SNPs[[count]] <-
spearman.correlations.between.core.SNPs
names(these.spearman.rank.correlation.between.GWAS.core.SNPs)[count] <-
this.setting
these.spearman.rank.correlation.between.GWAS.core.SNPs
these.spearman.rank.correlation.between.GWAS.peripheral.SNPs
these.spearman.rank.correlation.between.GWAS.peripheral.SNPs[[count]] <-
spearman.correlations.between.peripheral.SNPs
names(these.spearman.rank.correlation.between.GWAS.peripheral.SNPs)[count] <-
this.setting
these.spearman.rank.correlation.between.GWAS.peripheral.SNPs
#For the QTLs
source("QG_Analysis_Code/Run_GS_on_QTNs.R")
#For the SNPs
source("QG_Analysis_Code/Run_GS_on_SNPs.R")
#### Append GS Results
#Append results to the lists you created before the start of this rep
these.prediction.accuracies.QTNs[[count]] <- prediction.accuracies.QTNs
#Initiallize objects that will store GS results
these.prediction.accuracies.QTNs <- list()
these.prediction.accuracies.SNPs <- list()
#Append results to the lists you created before the start of this rep
these.prediction.accuracies.QTNs[[count]] <- prediction.accuracies.QTNs
names(these.prediction.accuracies.QTNs)[count] <- this.setting
these.prediction.accuracies.SNPs[[count]] <- prediction.accuracies.SNPs
names(these.prediction.accuracies.SNPs)[count] <- this.setting
#Update count for the next iteration of this loop
these.prediction.accuracies.QTNs
these.prediction.accuracies.SNPs
2^4
spearman.correlations.between.core.QTNs
spearman.correlations.between.core.SNPs
spearman.correlations.between.peripheral.QTNs
spearman.correlations.between.peripheral.SNPs
prediction.accuracies.QTNs
#Run the master script; source it in
source("Master_Analysis_Script_20240315.R")
pearman.correlations.between.core.QTNs
spearman.correlations.between.core.QTNs
